#summary An explanation and justification for the building blocks model used by Wax
#labels Phase-Design,Phase-Implementation,Featured

= Introduction =

If you've ever developed with a traditional web application framework, you know that there are 3 main parts:
 * Model
 * View
 * Controller

For a standard web application, these are the most important and most necessary pieces of the app.  However, as the web becomes more open and the semantic web becomes more predominant, there needs to be an easier way to piece together different types of information.

= The Building Blocks Model =

Wax is based off of the idea that there are several distinct parts that make up a web application.  While Models, Views, and Controllers are all important, they are all just parts of an application that serves a greater purpose than any one controller.  Wax Blocks are designed to hold several different types of data and make this data easily available for access no matter what the type.  Listed below are all the different possible parts of a Block:

 * *blocks* - Contain dependencies and private blocks
 * *css* - CSS Files used by this block
 * *images* - Images used by this block
 * *include* - 3rd party libraries needed for this block to function properly (ie: an LDAP authentication class)
 * *js* - Javascript files
 * *lib* - Role-based classes (Controllers,Models,etc.) based off of DCIObject
 * *roles* - Roles that provide functionality to objects
 * *views* - The view files used by the controllers in this block

The full directory tree of the Application Kit sample app is shown below: 
{{{
app.wax
 |- blocks/
 |   |- messageboxes.wax/
 |   |   |- css/
 |   |   |   |- exceptions.css
 |   |   |   \_ messageboxes.css
 |   |   |- images/
 |   |   |   |- error.png
 |   |   |   |- info.png
 |   |   |   |- success.png
 |   |   |   \_ warning.png
 |   |   |- lib/
 |   |   |- roles/
 |   |   |   \_ Flash.php
 |   |   \_ views/
 |   |       |- exception.view.php
 |   |       \_ message.view.php
 |   \_ webcore.wax/
 |       |- blocks/
 |       |   \_ scriptaculous.wax/
 |       |       \_ js/
 |       |           |- builder.js
 |       |           |- controls.js
 |       |           |- dragdrop.js
 |       |           |- effects.js
 |       |           |- scriptaculous.js
 |       |           |- slider.js
 |       |           |- sound.js
 |       |           \_ unittest.js
 |       |- css/
 |       |- images/
 |       |   \_ logo_standard.png
 |       |- js/
 |       |   \_ prototype.js
 |       |- lib/
 |       |   |- AppController.php
 |       |   |- Model.php
 |       |   \_ View.php
 |       |- roles/
 |       |   |- AppController.php
 |       |   |- Controller.php
 |       |   |- QueryStringRouter.php
 |       |   |- Scaffold.php
 |       |   \_ View.php
 |       \_ views/
 |           \_ HTML/
 |               |- input.view.php
 |               |- select.view.php
 |               \_ textarea.view.php
 |- css/
 |   \_ wax.css
 |- images/
 |   |- logo_small.png
 |   \_ logo_standard.png
 |- include/
 |- index.php
 |- js/
 |- lib/
 |   \_ HomeController.php
 |- roles/
 |- views/
 |   |- Home/
 |   |   \_ index.view.php
 |   |- footer.view.php
 |   \_ header.view.php
 \_ wax/
     |- include/
     |   |- DCIObject.php
     |   |- config.php
     |   |- exceptions.php
     |   |- lib.php
     |   \_ wax.php
     |- lib/
     |   |- ArraySurrogate.php
     |   |- HTTPArrays.php
     |   \_ WaxBlock.php
     |- managers/
     |   |- BlockManager.php
     |   \_ PathManager.php
     \_ wax_init.php
}}}

To make a block executable (ie: an application), an index.php file is included in the root of the block.  If the block is a standalone application, then the waxcore files are copied into block.wax/wax and are loaded by the index file (using `require_once "wax/wax_init.php"`).

 * index.php - Initializes Wax framework and sets up the main Application Controller
 * wax/ - Holds the core files required for Wax to function

An index.php file is only 3 lines for the most basic application:
{{{
<?php
    require_once dirname(__FILE__) . "/wax/wax_init.php";   // initialize the framework
    
    $app = new AppController();                             // Create an Application Controller
    $app->AppInit(dirname(__FILE__));                       // Initialize (Route) the Request
?>
}}}

Using this simple model, it becomes easy to chain together parts of an application to create a final product that is greater than the sum of its parts.  Some theoretical applications of this model are listed below:

= Applications of the Building Blocks Model = 

Let's say that you have a blog.  The MVC paradigm says that you should have Models, Views, and Controllers and that the application should be structured around this idea.  The Wax Model says that you should separate the models from the rest of the application and then build the blocks that provide a frontend to the model.  

With the semantic web and linked data becoming ever more popular, data is often requested in a variety of formats, whether it be HTML, XML, JSON, RDF, ATOM, etc.  With all of these different data formats available, a traditional framework can easily get cluttered with the views necessary for creating APIs to access this information.

== Separating the Model ==
DCI was originally conceived to organize the 'Model' aspect of MVC, and Wax takes advantage of this concept.  In a database-driven application, it is recommended that the application's models be placed in their own block, as shown below:

{{{
|- blocks/
 |   |- lib/
 |       |- models.wax/
 |           |- SomeModel.php
 |           |- SomeOtherModel.php
 |- index.php
}}}

In this way, the actual datasource for an application can be easily changed or modified.  This also means that the datasource for a Wax application doesn't necessarily need to be a traditional model.  Using this method, an Application API could be wrapped in a model class to allow for easy data retrieval and saving.

This also means that the model itself can have an interface for editing and viewing.  In this way, very simple administration interfaces can be scaffolded or the API for a model could be built into the model block itself.  This paradigm can be recursed to create large applications that retrieve data from a variety of sources, including but not limited to:

 * databases
 * XML, RSS, ATOM
 * application APIs
 * RDF
